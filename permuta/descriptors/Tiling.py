from builtins import dict
from collections import OrderedDict
from future.utils import iteritems
from .Tile import Tile
from .Perm import Perm
from .PermSet import PermSet
from permuta.descriptors import Descriptor
from permuta._perm_set.finite import PermSetFiniteSpecificLength
from permuta._perm_set.unbounded.described import PermSetDescribed


class Tiling(dict):
    """Tiling class.
    
    Coordinates are tuples of (i, j) which work in the traditional matrix way.
    """

    def __init__(self, tiles=()):
        info = []
        super(Tiling, self).__init__(self._init_helper(tiles, info))
        self._hash, self._max_i, self._max_j, self._total_point_tiles = info

    def _init_helper(self, tiles, info):
        POINT_PERM_SET = Tile.POINT_PERM_SET
        total_point_tiles = 0
        hash_sum = 0
        max_i = 0
        max_j = 0
        for key_val in tiles.items():  # Builds the tuple in python2
            hash_sum += hash(key_val)
            (i, j), perm_set = key_val
            if perm_set is POINT_PERM_SET:
                total_point_tiles += 1
            max_i = max(max_i, i)
            max_j = max(max_j, j)
            yield key_val
        info.append(hash(hash_sum))
        info.append(max_i)
        info.append(max_j)
        info.append(total_point_tiles)

    def __hash__(self):
        return self._hash

    def __repr__(self):
        format_string = "<A tiling of {} non-empty tiles>"
        return format_string.format(len(self))

    def __str__(self):
        max_i = self._max_i
        max_j = self._max_j

        result = []

        labels = OrderedDict()

        # Create tiling lines
        for i in range(2*max_i + 3):
            for j in range(2*max_j + 3):
                # Whether or not a vertical line and a horizontal line is present
                vertical = j % 2 == 0
                horizontal = i % 2 == 0
                if vertical:
                    if horizontal:
                        result.append("+")
                    else:
                        result.append("|")
                elif horizontal:
                    result.append("-")
                else:
                    result.append(" ")
            result.append("\n")

        # Put the sets in the tiles
        row_width = 2*max_j + 4
        for (i, j), perm_set in iteritems(self):
            label = labels.get(perm_set)
            if label is None:
                label = str(len(labels) + 1)
                labels[perm_set] = label
            index = (2*i + 1)*row_width + 2*j + 1
            result[index] = label

        # Legend at bottom
        for perm_set, label in iteritems(labels):
            result.append(label)
            result.append(": ")
            result.append(str(perm_set))
            result.append("\n")

        return "".join(result)


class TilingPermSetDescriptor(Descriptor):
    # TODO: Pluralize
    def __init__(self, tile):
        super(TilingPermSetDescriptor, self).__init__()
        self.tile = tile

    def __eq__(self, other):
        return isinstance(other, TilingPermSetDescriptor) and self.tile == other.tile

    def __hash__(self):
        # TODO: Hash without using sum?
        return hash(self.tile)

    def __repr__(self):
        return "<A descriptor subclass object for describing with a Tile>"


class TilingPermSet(PermSetDescribed):
    """A permutation set containing all permutations generated by a generating rule."""

    def __init__(self, descriptor):
        PermSetDescribed.__init__(self, descriptor)
        self.rule = descriptor.tile  # TODO: Don't be so hacky

    def __contains__(self, item):
        raise NotImplementedError

    def __getitem__(self, key):
        raise NotImplementedError

    def of_length(self, n):
        pass


T = Tiling({(0, 1): Tile.P, (1,1): Tile.P, (2,0): Tile.P, (2,2): Tile.P})
TD = TilingPermSetDescriptor(T)
TPS = TilingPermSet(TD)
